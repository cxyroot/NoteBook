

# SaaS和PaaS

在云计算非常热门的今天，很多人以为租赁个云主机就是云计算的全部。其实不然，云计算分为三个层级。从低到高分别是IAAS（基础架构即服务）、PAAS（平台即服务）、SAAS（软件即服务）。



软件即服务 (SaaS) 让用户能够通过 Internet 连接和使用基于云的应用程序。SaaS 提供完整的软件解决方案，你可以从云服务提供商处以即用即付方式进行购买。为组织租用应用，组织用户即可通过 Internet 连接到该应用（通常使用 Web 浏览器）。所有基础结构、中间件、应用软件和应用数据都位于服务提供商的数据中心内。

服务提供商负责管理硬件和软件，并根据适当的服务协议确保应用和数据的可用性和安全性。SaaS 让组织能够通过最低前期成本的应用快速建成投产。

平台即服务 (PaaS) 是云中的完整开发和部署环境，你可以使用其中资源交付内容，从基于云的简单应用到启用云的复杂企业应用程序皆可。你以即用即付的方式从云服务提供商处购买所需资源，并通过安全的 Internet 连接访问这些资源。

PaaS 让你无需购买和管理软件许可证、底层应用程序基础结构和中间件、容器业务流程协调程序或开发工具及其他资源，从而避免了开支和复杂操作。你管理自己开发的应用程序和服务，剩余事项一般由云服务提供商负责。

总结起来就是SaaS就是为用户提供了基于云的应用软件，PaaS则为开发人员提供了构建应用程序的环境与思维。借助于平台PaaS服务条件，你不需要考虑过多的硬件设施，不但可以方便的使用很多在构建应用而且还可以在必要的时候提供服务。而SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并且负责所有硬件设备实施与设施的维护等等系列服务产品。

# fastjson和gson

```json
相同点：都是根据JSON数据创建相应的类

不同点：
1.调用方式区别
    谷歌：方法都是非静态的，需要先创建对象，再去调用
    阿里：方法都是静态的，直接用类调用，不需要创建对象

2.方法区别：
谷歌：fromJson（参数1，参数2）
阿里：JSON.parseXX（参数1，参数2）
    具体是parseObject（）还是parseArray（），根据需要定



fastjson和gson是目前比较常用的json解析库，并且现在我们项目代码中，也在使用这两个解析库。

fastjson 是由阿里开发的，号称是处理json效率最高的框架。而gson 是由google开发的，是功能比较全面的json解析工具。
```





# 队列和栈的区别

```
栈和队列的共同点如下：

1、都是线性结构。

2、插入操作都是限定在表尾进行。

3、都可以通过顺序结构和链式结构实现。

4、插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。

5、多链栈和多链队列的管理模式可以相同。

栈与队列的不同点：

1、删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。

2、应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。

3、顺序栈能够实现多栈空间共享，而顺序队列不能。
```



# 线程安全

LinkedList和ArrayList是线程都是不同步的。线程不安全的。

Vector和Stack都是同步的，线程安全的,Set是线程不安全的

Hashtable的方法是同步的，线程安全的  

HashMap的方法不是同步的 线程不安全的



线程不安全 LinkedList/ArrayList/HashMap/Set

线程安全  Hashtable/Stack/Vector

# String比较

```java
String str1 = "123";
String str2 = new String("123");
System.out.println(str1.equals(str2));//true
System.out.println(str1 == str2);//false


String str = new String("123");
String str1 = "123";
System.out.println(str == str1);//false
System.out.println(str.equals(str1));//true
```

# HashMap的put方法

```java
public static void main(String[] args) {
    HashMap hashMap = new HashMap();
    hashMap.put("name","123");
    hashMap.put("name","1234567");
    hashMap.put("name",null);
    hashMap.put("name","123");
    System.out.println(hashMap.size());// 1
}
```



# Spirng Cloud Eureka

Spirng Cloud Eureka使用Netflix Eureka来实现服务注册与发现。它既包含了服务端组件，也包含了客户端组件，并且服务端与客户端均采用java编写，所以Eureka主要适用于通过java实现的分布式系统，或是JVM兼容语言构建的系统。Eureka的服务端提供了较为完善的REST API，所以Eureka也支持将非java语言实现的服务纳入到Eureka服务治理体系中来，只需要其他语言平台自己实现Eureka的客户端程序。目前.Net平台的Steeltoe、Node.js的eureka-js-client等都已经实现了各自平台的Ereka客户端组件。

# 拦截器和过滤器的区别

```
拦截器(Interceptor)，主要完成请求参数的解析、将页面表单参数赋给值栈中相应属性、执行功能检验、程序异常调试等工作。


java过滤器能够对目标资源的请求和响应进行截取。
```

# HashMap和TreeMap是否有序

HashMap是无序的，TreeMap是有序的（有序无序是针对key的）

# String 类型的比较

```java
int a = 3;
int b = 3;
String str = "考试";
String str1 = new String("考试");
System.out.println(str == str1);//false
System.out.println(a == b);//true
System.out.println(str.equals(str1));//true
```

# MySQL索引类型详解

索引的类型和存储引擎有关，每种存储引擎所支持的索引类型不一定完全相同。MySQL 索引可以从存储方式、逻辑角度和实际使用的角度来进行分类。

## 存储方式 

```
1) B-树索引
B-树索引又称为 BTREE 索引，目前大部分的索引都是采用 B-树索引来存储的。

B-树索引是一个典型的数据结构，其包含的组件主要有以下几个：
叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。
分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。
根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。

基于这种树形数据结构，表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行。

B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY 排序。但 B-树索引必须遵循左边前缀原则，要考虑以下几点约束：
查询必须从索引的最左边的列开始。
查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。
存储引擎不能使用索引中范围条件右边的列。
2) 哈希索引
哈希（Hash）一般翻译为“散列”，也有直接音译成“哈希”的，就是把任意长度的输入（又叫作预映射，pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。

哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B-树索引和 HASH 索引，且将 HASH 当成默认索引。

HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：
MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B-树索引来说，建立哈希索引会耗费更多的时间。
不能使用 HASH 索引排序。
HASH 索引只支持等值比较，如“=”“IN()”或“<=>”。
HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。
```

## 逻辑角度	

```
根据索引的具体用途，MySQL 中的索引在逻辑上分为以下 5 类：
1) 普通索引
普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。

普通索引允许在定义索引的列中插入重复值和空值。

创建普通索引时，通常使用的关键字是 INDEX 或 KEY。
例 1
下面在 tb_student 表中的 id 字段上建立名为 index_id 的索引。
CREATE INDEX index_id ON tb_student(id);

2) 唯一索引
唯一索引与普通索引类似，不同的是创建唯一性索引的目的不是为了提高访问速度，而是为了避免数据出现重复。

唯一索引列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一。

创建唯一索引通常使用 UNIQUE 关键字。
例 2
下面在 tb_student 表中的 id 字段上建立名为 index_id 的索引，SQL 语句如下：
CREATE UNIQUE INDEX index_id ON tb_student(id);

其中，id 字段可以有唯一性约束，也可以没有。
3) 主键索引
顾名思义，主键索引就是专门为主键字段创建的索引，也属于索引的一种。

主键索引是一种特殊的唯一索引，不允许值重复或者值为空。

创建主键索引通常使用 PRIMARY KEY 关键字。不能使用 CREATE INDEX 语句创建主键索引。
4) 空间索引
空间索引是对空间数据类型的字段建立的索引，使用 SPATIAL 关键字进行扩展。

创建空间索引的列必须将其声明为 NOT NULL，空间索引只能在存储引擎为 MyISAM 的表中创建。

空间索引主要用于地理空间数据类型 GEOMETRY。对于初学者来说，这类索引很少会用到。
例 3
下面在 tb_student 表中的 line 字段上建立名为 index_line 的索引，SQL 语句如下：
CREATE SPATIAL INDEX index_line ON tb_student(line);

其中，tb_student 表的存储引擎必须是 MyISAM，line 字段必须为空间数据类型，而且是非空的。
5) 全文索引
全文索引主要用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。在 MySQL 中只有 MyISAM 存储引擎支持全文索引。

全文索引允许在索引列中插入重复值和空值。

不过对于大容量的数据表，生成全文索引非常消耗时间和硬盘空间。

创建全文索引使用 FULLTEXT 关键字。
例 4
在 tb_student 表中的 info 字段上建立名为 index_info 的全文索引，SQL 语句如下：
CREATE FULLTEXT INDEX index_info ON tb_student(info);

其中，index_info 的存储引擎必须是 MyISAM，info 字段必须是 CHAR、VARCHAR 和 TEXT 等类型。
```

## 实际使用

```
索引在逻辑上分为以上 5 类，但在实际使用中，索引通常被创建成单列索引和组合索引。
1）单列索引
单列索引就是索引只包含原表的一个列。在表中的单个字段上创建索引，单列索引只根据该字段进行索引。

单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。
例 5
下面在 tb_student 表中的 address 字段上建立名为 index_addr 的单列索引，address 字段的数据类型为 VARCHAR(20)，索引的数据类型为 CHAR(4)。SQL 语句如下：
CREATE INDEX index_addr ON tb_student(address(4));

这样，查询时可以只查询 address 字段的前 4 个字符，而不需要全部查询。
2）多列索引
组合索引也称为复合索引或多列索引。相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。多列索引是在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。但是，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用。

例如，在表中的 id、name 和 sex 字段上建立一个多列索引，那么，只有查询条件使用了 id 字段时，该索引才会被使用。
例 6
下面在 tb_student 表中的 name 和 address 字段上建立名为 index_na 的索引，SQL 语句如下：
CREATE INDEX index_na ON tb_student(name,address);

该索引创建好了以后，查询条件中必须有 name 字段才能使用索引。
提示：一个表可以有多个单列索引，但这些索引不是组合索引。一个组合索引实质上为表的查询提供了多个索引，以此来加快查询速度。比如，在一个表中创建了一个组合索引(c1，c2，c3)，在实际查询中，系统用来实际加速的索引有三个：单个索引(c1)、双列索引(c1，c2)和多列索引(c1，c2，c3)。
```



# HashMap不是线程安全的

HashMap 是非线程安全的，如果在多线程环境下，可以使用 HashTable ， HashTable 中所有 CRUD 操作

都是线程同步的，同样的，线程同步的代价就是效率变低了。



再 Java 5 以后，有了一个线程安全的 HashMap——ConcurrentHashMap ， ConcurrentHashMap 相对
于 HashTable 来说， ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如 get,put,remove 等常
用操作只锁当前需要用到的桶。试想，原来只能一个线程进入，现在却能同时 16 个写线程进入（写线程
才需要锁定，而读线程几乎不受限制，并发性的提升是显而易见。



首先HashMap是线程不安全的。JDK1.7的时候采用头插法，多线程同时插入的时候，A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环。JDK1.8采用尾插法，会造成两种情况两个线程同时插入只有一个成功插入，还有就是可能会造成两次resize(++size>threshold) 。
解决的方案：一、使用HashTable效率比较差。二、使用ConcurrentHashMap比较常用的。三、使用Collections.synchronizedMap()
以上三种线程安全。





# WebLogic是应用服务器 不是分布式的

```
WebLogic是 美国Oracle公司 出品的一个application server，确切的说是一个基于 JAVAEE 架构的中间件  WebLogic是用于开发 、集成、部署和管理大型分布式Web应用、网络应用和数据库应用 的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。
```

# java中变量的命名规则

java中变量的命名规则是：

​	1、必须以字母、下划线或者美元符号开头；

​	2、变量名必须由字母、数字、下划线组成；

​	3、变量名不可以和java关键字冲突



# 动态代理

动态代理就是，在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。

两种常用的动态代理方式

基于接口的动态代理

​	提供者：JDK
​	使用JDK官方的Proxy类创建代理对象
​	注意：代理的目标对象必须实现接口

基于类的动态代理

​	提供者：第三方 CGLib
​	使用CGLib的Enhancer类创建代理对象
​	注意：如果报 asmxxxx 异常，需要导入 asm.jar包



# JUC并发包

java.util.concurrent

java.util.concurrent.atomic

java.util.concurrent.locks

# 进程/线程

```
什么是进程
我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志
进程具有的特征：
​	动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
​	并发性：任何进程都可以同其他进行一起并发执行；
​	独立性：进程是系统进行资源分配和调度的一个独立单位；
​	结构性：进程由程序，数据和进程控制块三部分组成


什么是线程

	在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片
轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。



进程与线程的区别
    1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
    2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
    3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信
    号等)，某进程内的线程在其他进程不可见；
    4. 调度和切换：线程上下文切换比进程上下文切换要快得多
```



# 多线程是什么

线程

操作 

资源



```java
package com.google;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Ticket{
	private int number = 300;
	Lock lock = new ReentrantLock();
	public void sale(){
		lock.lock();
		try {
			if(number > 0){
				System.out.println(Thread.currentThread().getName() +"\t卖出第："+(number--)+"\t 还剩："+number);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			lock.unlock();
		}
	}
	
}
public class LockDemo {
	public static void main(String[] args) {
		
		Ticket t = new Ticket();
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i <= 100; i++) {
					t.sale();
				}
			}
		},"A").start();
		
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i <= 100; i++) {
					t.sale();
				}
			}
		},"B").start();
		
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i <= 100; i++) {
					t.sale();
				}
			}
		},"C").start();
	}
}
```







# volatile是什么？

```
volatile是Java虚拟机提供的轻量级同步机制。1保证可见性2不保证原子性3禁止指令重排序
对JMM的理解
可见性是什么？
	工作内存和主内存的同步延迟问题就是可见性问题。	
原子性是什么？（不可分割，完整性。）
	
指令重排序是什么？
	
```

## volatile可见性

```java
package com.google;
//验证volatile的可见性
class MyData {

	volatile int number = 0;

	public void addTest6() {
		System.out.println(this.number);
		this.number = 60;
	}
}

public class Demo {
	public static void main(String[] args) {
		MyData myData = new MyData();
		new Thread(() -> {
			try {
				Thread.sleep(3000);
				myData.addTest6();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}, "AAA").start();

		while(myData.number == 0){
			
		}
		
		System.out.println("end");
		
	}
}
```

## volatile不保证原子性案例

```java
package com.google;
//volatile 不保证原子性
class MyData2 {
	volatile int number = 0;
	public void addPlus(){
		number++;
	}
}

public class Demo2 {
	public static void main(String[] args) {
		MyData2 myData2 = new MyData2();
		for (int i = 1; i <= 20; i++) {
			new Thread(() -> {
				for (int j = 1; j <= 1000; j++) {
					myData2.addPlus();
				}
			}, "AAA").start();
		}
		while(Thread.activeCount() > 2){
			Thread.yield();
		}
		System.out.println(myData2.number);//每次运行的值都不同
	}
}
```

## volatile不保证原子性的解决方案

```java
package com.google;

import java.util.concurrent.atomic.AtomicInteger;

//volatile 不保证原子性 
//解决volatile的原子性问题(synchronized)(AtomicInteger--->CAS) 
class MyData2 {
	AtomicInteger number = new AtomicInteger();
	public  void addPlus() {
		number.addAndGet(1);
	}
}

public class Demo2 {
	public static void main(String[] args) {
		MyData2 myData2 = new MyData2();
		for (int i = 1; i <= 20; i++) {
			new Thread(() -> {
				for (int j = 1; j <= 1000; j++) {
					myData2.addPlus();
				}
			}, "AAA").start();
		}
		while (Thread.activeCount() > 2) {
			Thread.yield();
		}
		System.out.println(myData2.number);
	}
}
```

## volatile的指令重排序

```java
package com.google;
//指令重排序
public class Demo3 {
	public static void main(String[] args) {
		mySort();
	}
	public static void mySort(){
		int x = 11;
		int y = 12;
		x = x + 5;
		y = x * x;
		System.out.println(x);
		System.out.println(y);
	}
}
```



# JMM的理解

```
JVM  java虚拟机是什么？

JMM 的三个特性1可见性2原子性3有序性

JMM （JAVA的内存模型） 本身是一种抽象的概念并不是真实存在的 是一组规则或者规范。通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式
JMM关于同步的规定
	1线程解锁前，必须把共享变量的值刷新回主内存
	2线程加锁前，必须读取主内存的最新值到自己的工作内存中
	3加锁解锁是同一把锁
 


```

# 你在什么地方用到过valatile？

## 单例模式在多线程环境下可能存在安全问题

```java
package com.google;
//单例模式
//单例模式在多线程环境下可能存在安全问题
public class SingletonDemo {
	private static SingletonDemo instance = null;
	
	private SingletonDemo(){
		System.out.println(Thread.currentThread().getName()+"我是构造方法");
	}
	
	public static SingletonDemo getInstance(){
		if (instance == null) {
			instance = new SingletonDemo();
		}
		return instance;
			
	}
	 
	public static void main(String[] args) {
		for (int i = 1; i <= 20; i++) {
			new Thread(()->{
				SingletonDemo.getInstance();
			},String.valueOf(i)).start();;
		}
		
	}
}
```

## 单例模式volatile分析

```java
package com.google;

//单例模式volatile分析
public class SingletonDemo {
	private static SingletonDemo instance = null;

	private SingletonDemo() {
		System.out.println(Thread.currentThread().getName() + "我是构造方法");
	}

	public static SingletonDemo getInstance() {
		if (instance == null) {
			// DCL模式 双端检锁机制
			synchronized (SingletonDemo.class) {
				if (instance == null) {
					instance = new SingletonDemo();
				}
			}
		}
		return instance;
	}

	// DCL模式
	public static void main(String[] args) {
		for (int i = 1; i <= 20; i++) {
			new Thread(() -> {
				SingletonDemo.getInstance();
			}, String.valueOf(i)).start();
			;
		}

	}
}
```

## 单例模式volatile分析

```java
package com.google;

public class SingletonDemo {
	//单例模式volatile分析
	private static volatile SingletonDemo instance = null;

	private SingletonDemo() {
		System.out.println(Thread.currentThread().getName() + "我是构造方法");
	}

	public static SingletonDemo getInstance() {
		if (instance == null) {
			// DCL模式 双端检锁机制
			synchronized (SingletonDemo.class) {
				if (instance == null) {
					instance = new SingletonDemo();
				}
			}
		}
		return instance;
	}

	// DCL模式
	public static void main(String[] args) {
		for (int i = 1; i <= Integer.MAX_VALUE; i++) {
			new Thread(() -> {
				SingletonDemo.getInstance();
			}, String.valueOf(i)).start();
			;
		}

	}
}
```

# CAS的使用

```
CAS比较并交换。compareAndSet 
	主物理内存
	工作内存
```

## AtomicInteger

```java
package com.google;

import java.util.concurrent.atomic.AtomicInteger;
public class CasDemo {
	public static void main(String[] args) {
		AtomicInteger atomicInteger = new AtomicInteger(5);
		atomicInteger.compareAndSet(12, 20);
		System.out.println(atomicInteger.get());
	}
}
/*
	public final boolean compareAndSet(int expect, int update) {
	    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
	}
*/
```



```java
AtomicInteger atomicInteger = new AtomicInteger(5);
//期望值和更新值
atomicInteger.compareAndSet(5, 20); 
System.out.println(atomicInteger.get());


AtomicInteger atomicInteger = new AtomicInteger(5);
atomicInteger.compareAndSet(12, 20);
System.out.println(atomicInteger.get());
```



# CAS的底层原理

```
自旋锁
Unsafe
```





# CAS的缺点

```
循环时间长CPU开销大

只能保证一个共享变量的原子性操作

引出ABA问题
```

# CAS使用后的ABA问题

```
原子更新引用
CAS--->UnSafe-->CAS底层思想--->ABA--->原子引用更新---->如何规避ABA问题
```



```java
package com.google;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicStampedReference;

//ABA问题的解决方式  加入版本号 使用AtomicStampedReference
public class CasDemo2 {

	static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);
	
	static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<Integer>(100, 1);

	public static void main(String[] args) {

		// AtomicInteger atomicInteger = new AtomicInteger();
		new Thread(() -> {
			// ABA
			atomicReference.compareAndSet(100, 101);
			atomicReference.compareAndSet(101, 100);
		}, "T1").start();

		new Thread(() -> {
			// ABA
			try {
				TimeUnit.SECONDS.sleep(1);
				System.out.println(atomicReference.compareAndSet(100, 2019));
				System.out.println(atomicReference.get());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}, "T2").start();

		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		new Thread(() -> {
			// ABA
			int stamp = atomicStampedReference.getStamp();
			System.out.println(Thread.currentThread().getName() + "第一次版本号：" + stamp);
			try {
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(),
					atomicStampedReference.getStamp() + 1);
			System.out.println(Thread.currentThread().getName() + ":第二次版本号：" + atomicStampedReference.getStamp());
			atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(),
					atomicStampedReference.getStamp() + 1);
			System.out.println(Thread.currentThread().getName() + ":第三次版本号：" + atomicStampedReference.getStamp());
		}, "T3").start();

		new Thread(() -> {
			int stamp = atomicStampedReference.getStamp();
			System.out.println(Thread.currentThread().getName() + ":取得的初始版本号:" + stamp);
			try {
				TimeUnit.SECONDS.sleep(3);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			boolean result = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);
			System.out.println("是否修改成功:" + result);
			System.out.println("最终的版本号:" + atomicStampedReference.getStamp());
		}, "T4").start();

	}
}


/*
true
2019
T3第一次版本号：1
T4:取得的初始版本号:1
T3:第二次版本号：2
T3:第三次版本号：3
*/
```

# AtomicReference原子引用

```
原子引用和原子时间戳问题

AtomicReference
```



```java
package com.google;

import java.util.concurrent.atomic.AtomicReference;

class User{
	String userName;
	int age;
	
	
	public User() {
		super();
	}
	public User(String userName, int age) {
		super();
		this.userName = userName;
		this.age = age;
	}
	@Override
	public String toString() {
		return "User [userName=" + userName + ", age=" + age + "]";
	}
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	
}
//AtomicReference原子引用
public class AtomicReferenceCasDemo3 {
	
	public static void main(String[] args) {
		User z3 = new User("z3",22);
		User li4 = new User("li4",33);
		
		AtomicReference<User>  atomicReference  = new AtomicReference<>();
		atomicReference.set(z3);
		
		System.out.println(atomicReference.compareAndSet(z3, li4));
		System.out.println(atomicReference.get().toString());
		
		
		System.out.println(atomicReference.compareAndSet(z3, li4));
		System.out.println(atomicReference.get().toString());
	}
}

```

# 使用版本号来解决ABA问题。

**AtomicStampedReference**版本号原子引用



# 集合类不安全之并发修改异常

```
ArrayList是线程不安全的集合类。
//解决方法
//Vector list = new Vector();
//List list = Collections.synchronizedList(new ArrayList<>());
```



```java
package com.google.t1;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
//集合类的安全性解决问题
//Vector list = new Vector();
//List list = Collections.synchronizedList(new ArrayList<>());
//加入同步代码块synchronized(list){}
//List list = new CopyOnWriteArrayList<>();
public class ArrayListDemo {
	public static void main(String[] args) {
		// java.util.ConcurrentModificationException
		// List list = new ArrayList<>();//Collections.synchronizedList(new ArrayList());
        List list = new CopyOnWriteArrayList<>();
		for (int i = 1; i <= 30; i++) {
			new Thread(() -> {
				synchronized(list){
					list.add(UUID.randomUUID().toString().substring(0, 8));
					System.out.println(list);
				}
			}).start();
		}
	}
}
```

# CopyOnWriteArrayList

写时复制

读写分离的思想



# 集合类不安全之Set--CopyOnWriteArraySet

```java
HashSet也是线程不安全的集合类。

package com.google.t1;

import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;

public class HashSetDemo {
	public static void main(String[] args) {
		Set set = new CopyOnWriteArraySet();
		
		for (int i = 1; i <= 30; i++) {
			new Thread(() -> {
				set.add(UUID.randomUUID().toString().substring(0, 8));
				System.out.println(set);
			}).start();
		}
	}
}
```

# 23_集合类不安全之Map--ConcurrentHashMap

```java
package com.google.t1;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class HashMapDemo {
	public static void main(String[] args) {
		//Map set = new HashMap<>();
		Map set = new ConcurrentHashMap<>();
		for (int i = 1; i <= 30; i++) {
			new Thread(() -> {
				set.put(Thread.currentThread().   (),UUID.randomUUID().toString().substring(0, 8));
				System.out.println(set);
			}).start();
		}
	}
}
/*
 * 
 * 
{Thread-4=85923a97, Thread-5=b6574559, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
Exception in thread "Thread-4" Exception in thread "Thread-1" Exception in thread "Thread-0" Exception in thread "Thread-2" Exception in thread "Thread-8" Exception in thread "Thread-11" Exception in thread "Thread-17" Exception in thread "Thread-13" Exception in thread "Thread-24" Exception in thread "Thread-22" {Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-14=9b1e95a5, Thread-12=a0536a2a, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-12=a0536a2a, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-11=799dbe93, Thread-10=f608c08d, Thread-15=f8016eb3, Thread-14=9b1e95a5, Thread-13=1cfb5415, Thread-12=a0536a2a, Thread-17=2e2c3ec5, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-12=a0536a2a, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
Exception in thread "Thread-20" {Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-11=799dbe93, Thread-22=ae1da55f, Thread-10=f608c08d, Thread-15=f8016eb3, Thread-14=9b1e95a5, Thread-13=1cfb5415, Thread-24=e37b2417, Thread-12=a0536a2a, Thread-19=605dfc97, Thread-18=6b8d3d0d, Thread-17=2e2c3ec5, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
Exception in thread "Thread-25" Exception in thread "Thread-21" {Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-11=799dbe93, Thread-22=ae1da55f, Thread-10=f608c08d, Thread-15=f8016eb3, Thread-14=9b1e95a5, Thread-13=1cfb5415, Thread-24=e37b2417, Thread-12=a0536a2a, Thread-18=6b8d3d0d, Thread-17=2e2c3ec5, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
Exception in thread "Thread-28" Exception in thread "Thread-23" Exception in thread "Thread-26" {Thread-22=ae1da55f, Thread-21=86f98874, Thread-20=18ca5c87, Thread-26=f9f4a174, Thread-25=7d9b3446, Thread-24=e37b2417, Thread-23=8fcbd498, Thread-28=3dd6742a, Thread-27=9ef6bfc0, Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-11=799dbe93, Thread-10=f608c08d, Thread-15=f8016eb3, Thread-14=9b1e95a5, Thread-13=1cfb5415, Thread-12=a0536a2a, Thread-19=605dfc97, Thread-18=6b8d3d0d, Thread-17=2e2c3ec5, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
{Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-11=799dbe93, Thread-10=f608c08d, Thread-14=9b1e95a5, Thread-12=a0536a2a, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
java.util.ConcurrentModificationException
{Thread-22=ae1da55f, Thread-21=86f98874, Thread-20=18ca5c87, Thread-26=f9f4a174, Thread-25=7d9b3446, Thread-24=e37b2417, Thread-23=8fcbd498, Thread-29=f5cf0663, Thread-28=3dd6742a, Thread-27=9ef6bfc0, Thread-3=32c63158, Thread-4=85923a97, Thread-5=b6574559, Thread-6=5ac8c13d, Thread-7=d5b6d13a, Thread-8=71c5e03f, Thread-9=7e12d79f, Thread-11=799dbe93, Thread-10=f608c08d, Thread-15=f8016eb3, Thread-14=9b1e95a5, Thread-13=1cfb5415, Thread-12=a0536a2a, Thread-19=605dfc97, Thread-18=6b8d3d0d, Thread-17=2e2c3ec5, Thread-16=24ed9749, Thread-0=29808f2c, Thread-1=76f85844, Thread-2=c7f8ec4f}
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at java.util.AbstractMap.toString(AbstractMap.java:554)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at com.google.t1.HashMapDemo.lambda$0(HashMapDemo.java:13)
	at java.lang.Thread.run(Thread.java:748)

*/
 
```





# Java的锁机制

## 可重入锁（也叫递归锁）

指的是同一个线程外层函数获得锁后，内层递归函数仍然能获取该锁的代码。

在同一个线程的外层方法获取锁的时候，在内层的方法会自动获取锁。

也就是说，线程可以进入任何一个它拥有的锁所同步着的代码块。

```
公平锁/非公平锁/可重入锁/递归锁/自旋锁

公平锁(FairSync)和非公平锁(NonfairSync)
```

## FairSync（公平锁）

是指多线程按照申请锁的顺序来获取锁，类似于排队

## NonfairSync（非公平锁）



## FairSync（公平锁）和NonfairSync（非公平锁）的总结

对于JavaReentrantLock而言  通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

对于sync 而言，也是一种非公平锁。



# java锁之可重入锁和递归锁代码验证

```java
package com.google.t3;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

//27_java锁之可重入锁和递归锁代码验证
//可重入锁的最大作用可以避免死锁
class Phone implements Runnable{
	
	public synchronized void sendSMS(){
		System.out.println(Thread.currentThread().getName() + " sendSMS");
		sendEMail();
	}
	public synchronized void sendEMail(){
		System.out.println(Thread.currentThread().getName() + " sendEMail");
	}
	@Override
	public void run() {
		get();
	}
	Lock lock = new ReentrantLock();
	private void get() {
		lock.lock();
		try {
			System.out.println(Thread.currentThread().getName() + " get()");
			set();
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			lock.unlock();
		}
	}
	private void set() {
		lock.lock();
		try {
			System.out.println(Thread.currentThread().getName() + " set()");
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			lock.unlock();
		}
	}
}

public class ReentrantLockDemo {
	public static void main(String[] args) {
		Phone phone = new Phone();
		
		new Thread(()->{
			phone.sendSMS();
		},"t1").start();
		
		new Thread(()->{
			phone.sendSMS();
		},"t2").start();
		
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("=============================");
		
		Thread t3  = new Thread(phone,"t3");
		t3.start();
		Thread t4  = new Thread(phone,"t4");
		t4.start();
	}
}
```



# 28_java锁之自旋锁理论知识

CAS下的自旋锁

是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。

好处  减少上下文的切换的消耗

缺点  循环会消耗CPU资源

自旋锁例子

```java
//sun.misc.Unsafe.getAndAddInt(Object, long, int)
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
    var5 = this.getIntVolatile(var1, var2);
    } while (!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```



# 29_java锁之自旋锁代码验证



```java
package com.google.t3;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

//java锁之自旋锁代码验证
public class SpinLockDemo {

	AtomicReference<Thread> atomicReference = new AtomicReference<>();

	public void myLock() {
		Thread thread  = Thread.currentThread();
		System.out.println(Thread.currentThread().getName()+"  come in ");
		
		while(!atomicReference.compareAndSet(null, thread)){
			
		}
	}
	public void myUnLock() {
		Thread thread = Thread.currentThread();
		atomicReference.compareAndSet(thread, null);
		System.out.println(Thread.currentThread().getName()+ "  myUnLock");
	}
	
	public static void main(String[] args) {
		SpinLockDemo spinLockDemo = new SpinLockDemo();
		
		new Thread(()->{
			spinLockDemo.myLock();
			try {
				TimeUnit.SECONDS.sleep(5);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			spinLockDemo.myUnLock();
		},"AA").start();
		
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		new Thread(()->{
			spinLockDemo.myLock();
			spinLockDemo.myUnLock();
		},"BB").start();
	}

}
```





# 30_Java锁之读写锁理论知识

独占锁

​			该锁一次只能被一个线程锁持有，对

共享锁

# 独占锁

指该锁一次只能被一个线程所持有。对ReentrantLock和Synchrinized而言都是独占锁。

# 共享锁

指该锁可被多个线程所持有。

对ReentrantReadWriteLock其读锁试试共享锁，其写锁是独占锁。

读锁的共享锁可保证并发读是非常高效的，

读写，写读，写写的过程是互斥的。



# 31_Java锁之读写锁代码验证



多个线程同时读一个资源没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。

但是如果有一个线程去写共享资源来，就不应该有其他线程可以对该资源进行读或者写。

小总结

​			读--读  能共存

​			读--写  不能共存

​			写--写  不能共存

```java
package com.google.t3;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

//31_Java锁之读写锁代码验证
class MyCache{
	
	private volatile Map<String,Object> map  = new HashMap<>();
	
	private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
	
	public void put(String key,Object value){
		reentrantReadWriteLock.writeLock().lock();
		try {
			System.out.println(Thread.currentThread().getName()+"  正在写入。。" + key);
			try {
				TimeUnit.MICROSECONDS.sleep(300);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			map.put(key, value);
			System.out.println(Thread.currentThread().getName()+"  写入。。完成");
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			reentrantReadWriteLock.writeLock().unlock();
		}
	}
	
	public void get(String key){
		reentrantReadWriteLock.readLock().lock();
		try {
			System.out.println(Thread.currentThread().getName()+"  正在读取。。" );
			try {
				TimeUnit.MICROSECONDS.sleep(300);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			Object obj = map.get(key);
			System.out.println(Thread.currentThread().getName()+"  读取。。完成"+ obj);
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			reentrantReadWriteLock.readLock().unlock();
		}
		
		
	}
	
}

public class ReadWriteLockDemo { 
	
	public static void main(String[] args) {
		
		MyCache myCache = new MyCache();
		for ( int i = 1; i <= 5; i++) {
			final int temp = i;
			new Thread(()->{
				myCache.put(String.valueOf(temp), String.valueOf(temp));
			},String.valueOf(i)).start();;
		}
		
		for (int j = 1; j <= 5; j++) {
			final int temp = j;
			new Thread(()->{
				myCache.get(String.valueOf(temp));
			},String.valueOf(j)).start();
		}
	}
}

```



# 32_CountDownLatch

CountDownLatch 的作用很简单，就是一个或者一组线程在开始执行操作之前，必须要等到其他线程执行完才可以。

```java
package com.google.t3;

import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
	
	public static void main(String[] args) {
		CountDownLatch  countDownLatch  = new CountDownLatch(6);
		for (int i = 1; i <= 6; i++) {
			new Thread(()->{
				System.out.println(Thread.currentThread().getName());
				countDownLatch.countDown();
			},String.valueOf(i)).start();
		} 
		
		try {
			countDownLatch.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName() + "结束");
	}
} 
```

# 33_CydicBarrier







# 34_Semaphore





# ThreadPool





# 队列

​	先到先得

# 35_阻塞队列理论



BlockingQueue

# 36_阻塞队列接口和实现类

```
ArrayBlockingQueue是一个底层结构是数组的阻塞队列，是通过 ReentrantLock 和 Condition 来实现的。
不可插入为null的元素，入队和出队使用的是同一个锁。意味着同一时刻只能有一个线程能进行入队或者出队操作。
入队时，队列已满则会调用notFull.await()，进入阻塞状态。直到队列不满时，再进行入队操作。
当出队时，队列为空，则调用notEmpty.await()，进入阻塞状态，直到队列不为空时，则出队。
```

# 37_阻塞队列api之抛出异常

```java
package com.google.t3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class BlockingQueueDemo {
	public static void main(String[] args) {
		
		 BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); 
		 blockingQueue.add("a");
		 blockingQueue.add("b");
		 blockingQueue.add("c");
		 blockingQueue.add("a");
		 
		 System.out.println(blockingQueue.element());
		 
		 
		 System.out.println(blockingQueue.remove());
		 System.out.println(blockingQueue.remove());
		 System.out.println(blockingQueue.remove());
		 System.out.println(blockingQueue.remove());
	}
}
```

# 38_阻塞队列api之返回布尔值组

```java
package com.google.t3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class BlockingQueueDemo {
	public static void main(String[] args) {
		
		 BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); 
		
		 System.out.println(blockingQueue.offer("a1"));
		 System.out.println(blockingQueue.offer("a2"));
		 System.out.println(blockingQueue.offer("a3"));
		 System.out.println(blockingQueue.offer("a4"));
		 System.out.println(blockingQueue.offer("a5"));
		 System.out.println(blockingQueue.offer("a6"));
	
		 System.out.println(blockingQueue.peek());
		 
		 System.out.println(blockingQueue.poll());
		 System.out.println(blockingQueue.poll());
		 System.out.println(blockingQueue.poll());
		 System.out.println(blockingQueue.poll());
		 System.out.println(blockingQueue.poll());
		 System.out.println(blockingQueue.poll());
		 
	}
}
```

# 39_阻塞队列api之阻塞和超时控制



```java
package com.google.t3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class BlockingQueueDemo {
	public static void main(String[] args) {

		BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

		try {
			blockingQueue.put("a1");
			blockingQueue.put("a2");
			blockingQueue.put("a3");
			blockingQueue.put("a4");
			System.out.println(blockingQueue.take());
			System.out.println(blockingQueue.take());
			System.out.println(blockingQueue.take());
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

```

```java
package com.google.t3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

public class BlockingQueueDemo {
	public static void main(String[] args) {

		BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

		try {
			blockingQueue.put("a1");
			blockingQueue.put("a2");
			blockingQueue.put("a3");
			blockingQueue.offer("a4", 2L,TimeUnit.SECONDS);
			
			System.out.println(blockingQueue.take());
			System.out.println(blockingQueue.take());
			System.out.println(blockingQueue.take());
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

```

# 40_阻塞队列之同步SynchronousQueue队列



```java
package com.google.t3;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;

public class SynchronousQueueDemo {
	public static void main(String[] args) {
		
		
		BlockingQueue<String> boBlockingQueue = new SynchronousQueue<>();
		
		new  Thread(()->{
			try {
				boBlockingQueue.put("1");
				boBlockingQueue.put("2");
				boBlockingQueue.put("3");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		},"AA").start();;
		
		new  Thread(()->{
			try {
				Thread.sleep(50);
				System.out.println(boBlockingQueue.take());
				System.out.println(boBlockingQueue.take());
				System.out.println(boBlockingQueue.take());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		},"AA").start();;
	}
}
```



# 41_线程通信之生产者消费者传统版



# 42_Synchronized和Lock有什么区别

```
区别1：Synchronized 是Java的一个关键字，而Lock是java.util.concurrent.Locks 包下的一个接口；

区别2：Synchronized 使用过后，会自动释放锁，而Lock需要手动上锁、手动释放锁。（在 finally 块中）

区别3：Lock提供了更多的实现方法，而且 可响应中断、可定时， 而synchronized 关键字不能响应中断


区别4：synchronized关键字是非公平锁，即，不能保证等待锁的那些线程们的顺序，而Lock的子类ReentrantLock默认是非公平锁，但是可通过一个布尔参数的构造方法实例化出一个公平锁；

区别5：synchronized无法判断，是否已经获取到锁，而Lock通过tryLock()方法可以判断，是否已获取到锁；

区别6：Lock可以通过分别定义读写锁提高多个线程读操作的效率。

区别7：二者的底层实现不一样：synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略（底层基于volatile关键字和CAS算法实现
```



# Callable

```java
package com.google;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;

class MyThread1 implements Runnable {

    @Override
    public void run() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("com.google.MyThread1.run");
    }
}

class MyThread implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        System.out.println("com.google.MyThread.call");
        return 1024;
    }
}

public class ThreadDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //Thread(Callable,"name");
        FutureTask<Integer> futureTask = new FutureTask<>(new MyThread());

        Thread thread = new Thread(futureTask, "AA");
        Thread thread2 = new Thread(futureTask, "AA");
        Thread thread3 = new Thread(futureTask, "AA");
        thread.start();
        thread2.start();
        thread3.start();


        Integer integer = null;
        int i1 = 100;

        while (!futureTask.isDone()) {

        }

        int i2 = futureTask.get();
        integer = i1 + i2;

        System.out.println(integer);
    }
}
```



# 47_线程池3个常用方式ExecutorService

Executors类的底层实现便是ThreadPoolExecutor！ Executors 工厂方法有：

Executors.newCachedThreadPool()：无界线程池，可以进行自动线程回收
Executors.newFixedThreadPool(int)：固定大小线程池
Executors.newSingleThreadExecutor()：单个后台线程



```java
package com.google.t3;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThredDemo2 {
	public static void main(String[] args) {
		
		ExecutorService thExecutorService1 = Executors.newSingleThreadExecutor();// 一池一线程
		
		ExecutorService thExecutorService = Executors.newFixedThreadPool(10);
		
		ExecutorService thExecutorService2 = Executors.newCachedThreadPool();
		
		try {
			for (int i = 0; i <= 20; i++) {
				thExecutorService2.execute(() -> {
					System.out.println(Thread.currentThread().getName() + "\t");
				});
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			thExecutorService2.shutdown();
		}
        
	}
}

```

# 48_线程池7大参数入门简介ThreadPoolExecutor

```java
int corePoolSize,//1 线程池中的常驻线程数 
int maximumPoolSize,//2 最大的线程数
long keepAliveTime,//3  多余线程的存活时间
TimeUnit unit,//4 存活时间的单位
BlockingQueue<Runnable> workQueue,//5 任务队列  被提交但是尚未被执行的资源
ThreadFactory threadFactory,//6 表示生成线程池中的工作线程
RejectedExecutionHandler handler//7 拒绝策略 
```

# ThreadMXBean

```java
package com.google.t3;

import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;

public class SyncDemo {
	public static void main(String[] args) {
		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
		for (ThreadInfo threadInfo : threadInfos) {
			System.out.println(threadInfo.getThreadId()+"\t"+threadInfo.getThreadName());
		}
	}
}

```



# Linux命令的性能评估



```
整机使用 top

CPU  vmstat

内存  free

硬盘  df

磁盘IO  iostat

网络 IO  ifstat
```



































































